<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Getting Started • l1rotation</title>
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><script src="../deps/MathJax-3.2.2/tex-chtml.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Getting Started">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">l1rotation</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/documentation.html">Getting Started</a></li>
    <li><a class="dropdown-item" href="../articles/intuition.html">Background and Intuition</a></li>
    <li><a class="dropdown-item" href="../articles/macro_application.html">Application</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/SimonFreyaldenhoven/l1rotation/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Getting Started</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/SimonFreyaldenhoven/l1rotation/blob/HEAD/vignettes/documentation.Rmd" class="external-link"><code>vignettes/documentation.Rmd</code></a></small>
      <div class="d-none name"><code>documentation.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="intro">Introduction<a class="anchor" aria-label="anchor" href="#intro"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/SimonFreyaldenhoven/l1rotation" class="external-link">l1rotation</a></span><span class="op">)</span></span></code></pre></div>
<p>The <code>l1rotation</code> package offers functionality to estimate
the loadings matrix in factor models based on the l1-rotation criterion
following <a href="https://simonfreyaldenhoven.github.io/papers/factor_rotation.pdf" class="external-link">Freyaldenhoven
(2025)</a>. The key idea of this estimator is assuming a sparsity
pattern in the loadings matrix solves the problem of rotational
indeterminacy inherent to factor models.</p>
<p>Factor models take the form</p>
<p><span class="math display">\[
X = F \Lambda^{*'} + e
\]</span> where</p>
<ul>
<li><p><span class="math inline">\(X\)</span> is a <span class="math inline">\(T \times n\)</span> data matrix, where there are
<span class="math inline">\(T\)</span> rows and <span class="math inline">\(n\)</span> variables, or columns</p></li>
<li><p><span class="math inline">\(F\)</span> is a <span class="math inline">\(T \times r\)</span> matrix of <span class="math inline">\(r\)</span> factors that the data is decomposed
into</p></li>
<li><p><span class="math inline">\(\Lambda^{*'}\)</span> is an <span class="math inline">\(r \times n\)</span> matrix of true
loadings</p></li>
<li><p><span class="math inline">\(e\)</span> is a <span class="math inline">\(T \times n\)</span> error matrix.</p></li>
</ul>
<p>This package is designed to identify and estimate <span class="math inline">\(\Lambda^{*}\)</span> subject to additional
sparsity assumptions detailed in <a href="https://simonfreyaldenhoven.github.io/papers/factor_rotation.pdf" class="external-link">Freyaldenhoven
(2025)</a>.</p>
</div>
<div class="section level2">
<h2 id="start">Quick start<a class="anchor" aria-label="anchor" href="#start"></a>
</h2>
<p>We will use the <code>example_data</code> data that ships with the
package to show its basic functionality. This data is a matrix
containing numeric information with <span class="math inline">\(n =
224\)</span>, <span class="math inline">\(T = 207\)</span>. In general,
data.frames, tibbles, or other data types can also be used with
<code>l1rotation</code> functions, as long as all columns are numeric.
Note also that the package cannot handle missing values in the data
matrix.</p>
<p>To start, let’s look at the first seven columns of the example
data:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">example_data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">7</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;            V1       V2          V3         V4         V5          V6         V7</span></span>
<span><span class="co">#&gt; [1,] 2.973310 3.563021 -0.04496568 -0.1700720  0.3350881  0.05244918 -1.1922173</span></span>
<span><span class="co">#&gt; [2,] 4.648603 4.817172  0.11200137 -0.5456076  0.1992616  0.33365310 -1.1699467</span></span>
<span><span class="co">#&gt; [3,] 4.162014 3.169177 -1.37955943 -2.5864043 -2.9352645 -0.79856910 -1.7227167</span></span>
<span><span class="co">#&gt; [4,] 2.097454 0.833101 -2.72023404 -2.9061952 -2.7111563 -0.18925022 -1.5973617</span></span>
<span><span class="co">#&gt; [5,] 1.783429 0.364707 -2.24466997 -1.9397028 -0.2521484  1.14563662 -0.6416022</span></span>
<span><span class="co">#&gt; [6,] 5.699166 3.932394  0.46050753 -0.5615002  2.3014500  2.22261949  0.5748873</span></span></code></pre></div>
<p>We assume that the number of underlying factors can be learned from
the data (following the procedure in <a href="https://onlinelibrary.wiley.com/doi/epdf/10.1111/1468-0262.00273" class="external-link">Bai
and Ng (2002)</a>). For the <code>example_data</code> we will use two
factors. With just the data, <span class="math inline">\(X\)</span>, and
the number of factors, <span class="math inline">\(r\)</span>, we can
start estimating the loadings with <code><a href="../reference/local_factors.html">local_factors()</a></code>. This
function estimates <span class="math inline">\(\Lambda^{*}\)</span> and
provides helpful diagnostics and figures.</p>
<p>Below is an example using <code>example_data</code> (note that
estimation can also be run in parallel with a selected number of cores,
<code>n_cores</code>):</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">916</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_factors.html">local_factors</a></span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="va">example_data</span>, r <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">FALSE</span>, n_cores <span class="op">=</span> <span class="cn">NULL</span> <span class="co"># Runs non-parallel by default</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In the estimation, <code><a href="../reference/local_factors.html">local_factors()</a></code> has reasonable
defaults set so the only required arguments are the data you’re
decomposing and the number of factors. We use the principal components
estimator as the initial estimate of the loadings, <span class="math inline">\(\Lambda_0\)</span>, which can be accessed via the
<code>Lambda0</code> item of the output. The function also computes a
quick diagnostic to check whether local factors are present in the data
which is given in the output item <code>has_local_factors</code>.</p>
<p>Additionally, there are several rotation diagnostics accessible via
<code>rotation_diagnostics</code> which give the rotation matrix, <span class="math inline">\(R\)</span> that when multiplied by <span class="math inline">\(\Lambda_0\)</span> produces <span class="math inline">\(\hat{\Lambda}^*\)</span>, the value of the l1 norm
for each vector, and the frequency that each solution appears in the
initial grid of estimates.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">rotation_diagnostics</span></span>
<span><span class="co">#&gt; $R</span></span>
<span><span class="co">#&gt;             R          </span></span>
<span><span class="co">#&gt; V1  0.7011144 0.8388980</span></span>
<span><span class="co">#&gt; V2 -0.7130488 0.5442886</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $fval</span></span>
<span><span class="co">#&gt; [1] 145.705 149.850</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sol_frequency</span></span>
<span><span class="co">#&gt; [1] 259 241</span></span></code></pre></div>
<p>For a visual interpretation of this rotation, we provide tile plots
contrasting the initial estimate <span class="math inline">\(\Lambda_0\)</span>, <code>pc_plot</code> and the
rotated estimate, <span class="math inline">\(\hat{\Lambda}^*\)</span>,
<code>rotated_plot</code>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">pc_plot</span></span></code></pre></div>
<p><img src="documentation_files/figure-html/unnamed-chunk-5-1.png" width="480" style="display: block; margin: auto;"></p>
<p>In the initial principal component estimate, recall that each factor
is simply a principal component. Of the 207 variables in <span class="math inline">\(X\)</span>, the first factor loads negatively
along the variables between 90 and 120, and slightly negatively almost
everywhere else. Along the second factor, there are positive loadings
between variables 125 and 200 and slightly negative loadings elsewhere.
However, it may be difficult to interpret the relationship between
variables and factors when all loadings are nonzero.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">rotated_plot</span></span></code></pre></div>
<p><img src="documentation_files/figure-html/unnamed-chunk-6-1.png" width="480" style="display: block; margin: auto;"></p>
<p>The second estimate is a rotated version of the principal components
estimator optimized for sparsity. It will rotate each vector of the
principal components loadings matrix until it finds a set of factors
that are as sparse as possible. As we can see, the second plot may
provide a stronger interpretation as variables 90-200 load negatively on
the first factor while variables 0-120 load negatively on the second
factor. The loadings along the other variables are close to zero,
suggesting no relationship. With this rotation, we can more easily
identify which sets of variables are related to which latent factors due
to the revealed sparsity pattern.</p>
</div>
<div class="section level2">
<h2 id="details">Refining the details<a class="anchor" aria-label="anchor" href="#details"></a>
</h2>
<p><code>l1rotation</code> supplies two additional functions,
<code><a href="../reference/find_local_factors.html">find_local_factors()</a></code> and <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code>
which provide additional functionality to support the main
<code><a href="../reference/local_factors.html">local_factors()</a></code> function.</p>
<div class="section level3">
<h3 id="flf">
<code>find_local_factors()</code><a class="anchor" aria-label="anchor" href="#flf"></a>
</h3>
<p>This function has an additional argument, <code>Lambda0</code>, that
allows the user to specify any orthonormal basis of the loadings rather
than defaulting to the principal component estimator. Here are some
plausible alternative initial estimates:</p>
<ul>
<li><p>MLE estimation</p></li>
<li><p>Sparse Orthogonal Factor Regression (SOFAR) as in <a href="http://faculty.marshall.usc.edu/yingying-fan/publications/IEEEIT-UFCLL19.pdf" class="external-link">Uematsu
et al. (2019)</a>.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="tlf">
<code>test_local_factors()</code><a class="anchor" aria-label="anchor" href="#tlf"></a>
</h3>
<p>This function tests for the presence of local factors given an
estimate of the loadings matrix, <code>Lambda</code>. Since the results
in this package rely upon a sparsity pattern in the true loadings
matrix, <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code> provides a simple diagnostic
to check this assumption.</p>
<p>For a given loading matrix estimate, <span class="math inline">\(\hat{\Lambda}\)</span>, we can consider maximizing
across factors the number of individual loadings in <span class="math inline">\(\hat{\Lambda}\)</span> smaller than some threshold
<span class="math inline">\(h_n\)</span>. This gives us an idea of how
many “small” loadings there are in <span class="math inline">\(\hat{\Lambda}\)</span>:</p>
<p><span class="math display">\[
\mathcal{L(\hat{\Lambda})} = \max_k\left(\sum_{i=1}^n
1\{\hat{|\lambda}_{ik}| &lt; h_n \}\right)
\]</span> With this number, we can then check whether the number of
“small” loadings is larger than <span class="math inline">\(\gamma
n\)</span></p>
<p><span class="math display">\[
\texttt{has_local_factors} = 1\{\mathcal{L}(\hat{\Lambda})  \geq \gamma
n \}.
\]</span></p>
<p>Returning to our <code>lf</code> results, we can take a look at the
value of <code>has_local_factors</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lf</span><span class="op">$</span><span class="va">has_local_factors</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>This value is the result of <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code>. To
verify, we can call <code><a href="../reference/test_local_factors.html">test_local_factors()</a></code> on two different
estimates: the principal components estimate, <code>Lambda0</code>, and
the l1rotation estimate, <code>Lambda</code>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Check for local factors in PC estimate...</span></span>
<span><span class="va">test_pc_estimate</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_local_factors.html">test_local_factors</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">example_data</span>, r <span class="op">=</span> <span class="fl">2</span>, loadings <span class="op">=</span> <span class="va">lf</span><span class="op">$</span><span class="va">initial_loadings</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># And rotated estimate</span></span>
<span><span class="va">test_rot_estimate</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_local_factors.html">test_local_factors</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">example_data</span>, r <span class="op">=</span> <span class="fl">2</span>, loadings <span class="op">=</span> <span class="va">lf</span><span class="op">$</span><span class="va">rotated_loadings</span><span class="op">)</span></span>
<span></span>
<span><span class="va">test_pc_estimate</span><span class="op">$</span><span class="va">has_local_factors</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="va">test_rot_estimate</span><span class="op">$</span><span class="va">has_local_factors</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>This confirms that no local factors are detected in the principal
components estimate (no sparsity pattern is observed), and that local
factors are present in the rotated estimate.</p>
<ul>
<li>Note that rotating the initial estimate, optimizing for sparsity, is
not guaranteed to produce a sparse loadings matrix if the true loadings
matrix itself is not sparse. However, if a sparsity pattern does exist
in the true loadings matrix, this procedure will recover it.</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">round_hn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">test_rot_estimate</span><span class="op">$</span><span class="va">h_n</span>, digits <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lf</span><span class="op">$</span><span class="va">small_loadings_plot</span> <span class="op">+</span> </span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span></span>
<span>    title <span class="op">=</span> <span class="st">'Number of "small" loadings per factor'</span>, </span>
<span>    caption <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">'"Small" is defined as loadings less than'</span>, <span class="va">round_hn</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p><img src="documentation_files/figure-html/unnamed-chunk-9-1.png" width="480" style="display: block; margin: auto;"></p>
<p>Finally, given the testing plot above, we can conclude that factors 1
and 2 are likely local since they have enough “small” loadings (i.e.,
smaller than a value of <span class="math inline">\(h_n = 1/\log(n)
=\)</span> 0.188 in the <code>example_data</code>).</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Simon Freyaldenhoven, Ryan Kobler.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
